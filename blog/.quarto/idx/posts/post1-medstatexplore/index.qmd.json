{"title":"Making sense of Medstat.dk data","markdown":{"yaml":{"title":"Making sense of Medstat.dk data","author":"Henrik Vitus Bering Laursen","date":"2024-09-19","categories":["code","analysis","exploration","cost","drugs"],"image":"thumbnail.png","freeze":true},"headingText":"Exploring Medstat data: Drug prescriptions in Denmark","containsRefs":false,"markdown":"\n\n\nIn this post, I'll showcase how to work with publicly available drug prescription data from [medstat.dk](medstat.dk \"medstat.dk\"). This is a great way to practice data manipulation and analysis, using real-world data.\n\n### Downloading the data\n\nYou can download all the datasets from [medstat.dk's download section](https://medstat.dk/da/download). If you want to download multiple files and not have to work with the URLs, I recommend using the [downloadthemall](https://www.downthemall.net/) extension to batch download the data for easier local manipulation. \n\nSince I’m using GitHub to store my work, I’ll download the data directly from Medstat. GitHub has a 2GB storage limit per repository, which means large public datasets can quickly exceed this. Therefore, it’s important to manage the size of the files efficiently.\n\n### Loading and processing the data\n\nGood old trusty `tidyverse` has a lot of what I need, specifically the `readr` package, \"secretly\" loaded the library in an invisible chunk below, with `#| include: FALSE`, but also `#| warning: FALSE` because it wants to warn me about conflicts with the `tidyverse` package.\n    \n    #| include: FALSE\n    #| warning: FALSE\n    library(tidyverse)\n\n```{r}\n#| include: FALSE\n#| warning: FALSE\n\nlibrary(tidyverse)\n```\n\n### Fetching the data from medstat\n\nYou can use tools like the [MarkDownload](https://github.com/deathau/markdownload) extension to find the download links from the resulting markdown file it hands you. \n\nNow lets load an example dataset. \n\n```{r}\n#| message: FALSE\n\n# Define the URL for the dataset ()\nurl_atc_2023 <- \"https://medstat.dk/da/download/file/MjAyM19hdGNfY29kZV9kYXRhLnR4dA==\"\n\n# Read the dataset directly from the URL\ndf_atc_2023 <- read_delim(url_atc_2023, delim = \";\", show_col_types = FALSE)  # Assuming the file is tab-delimited\n\n# Print the first few rows of the dataset\nhead(df_atc_2023)\n```\n\nOk, this data is without headers. A way to save space probably. \n\n### Understanding the data structure\n\n**Thankfully** there is a documentation file the website: [Downloadbeskrivelse medstat](https://medstat.dk/apps/lms/public/dokumentation/Downloadbeskrivelse.pdf). This file explains the strucutre of the datasets and for the data that we look at, `YYYY_atc_code_data.txt`, the following variables apply (translated to English from the original Danish):\n\n- `atc`: Anatomical Therapeutic Chemical code\n- `year`: Year of data\n- `sector`: Healthcare sector\n- `region`: Geographic region\n- `sex`: Gender\n- `agegroup`: Age category\n- `count_persons`: Number of individuals\n- `count_persons_per1kpop`: Number of individuals per 1,000 population\n- `turnover`: Sales turnover\n- `reimbursement`: Reimbursements provided\n- `sold_amount`: Amount of drugs sold\n- `sold_amount_1kpop_day`: Amount sold per 1,000 population per day\n- `personreferabledata_perc`: Percentage of data referable to individuals\n\nSo we can use `colnames()` to transfer these column names to our dataset.\n\n```{r}\n# attach colnames\ncolnames(df_atc_2023) <- c(\"atc\",\"year\",\"sector\",\"region\",\"sex\",\"agegroup\",\"count_persons\",\"count_persons_per1kpop\",\"turnover\",\"reimbursement\", \"sold_amount\", \"sold_amount_1kpop_day\", \"personreferabledata_perc\")\n\n# View data\nhead(df_atc_2023)\nglimpse(df_atc_2023)\n```\n\nMissing name for one column that doesnt fit with the \"Downloadbeskrivelse medstat\". What is it?\n\n```{r}\n# call it something\ncolnames(df_atc_2023)[is.na(colnames(df_atc_2023))] <- \"missing_name\"\n\n# table of content\ntable(df_atc_2023$missing_name)\n\n```\n\nThis column is empty. Maybe just an artifact from the delim file. Lets assume we can safely remove it.\n\n```{r}\ndf_atc_2023 <- df_atc_2023 |>  select(-missing_name)\n```\n\n### Organising the data\n\nTime to figure out how this data is structured, and organise the character variables into factors. Factors, as you may know, are a data structure in R, which is akin to a categorisation, ordered or unordered. Since we have age, we probably have at least some age categories that are ordered in intervals. Lets find out what the different variables likely to be factors are.\n\n```{r}\n#| results: 'hide'\n\n# Finding all unique values even though i could just consult \"Downloadbeskrivelse medstat\"\nunique_values_all_columns <- unique(unlist(sapply(df_atc_2023, function(x) if(is.character(x)) unique(x))))\nprint(unique_values_all_columns)\n```\n\nWoops. I have hidden the massive output of this via `#| results: 'hide'`. I forgot that ATC has QUITE a lot of unique values. Lets make a data frame without the atc value.\n\n```{r}\n# Remove atc\ndf_atc_2023_mini <- df_atc_2023 |>  select(-atc)\n\n# Go through all variables that could be categories (often stored as characters by default) and display unique values\nunique(unlist(sapply(df_atc_2023_mini, function(x) if(is.character(x)) unique(x))))\n\n```\n\nOr, in a little more legible fashion, use some apply functions to first find the ones that are characters with `sapply()`, and then `lapply()` to create a list of all unique values of the character vars.\n\n```{r}\n# find character variables\nchar_columns <- df_atc_2023_mini[sapply(df_atc_2023_mini, is.character)]\n\n# apply the unique() function to each character variable\nunique_char_values <- lapply(char_columns, unique)\nunique_char_values\n\n```\n\n\nMore manageable amount of unique values. Although it seems there are multiple age categories within the `agegroup` variable. I will remove `df_atc_2023_mini` and `unique_char_values` as they were created for the purpose of creating an overview of the unique values.\n\n```{r}\nrm(df_atc_2023_mini, unique_char_values)\n```\n\nLets focus on the unique age groups. The data for age groups must be duplicated for the ranges 000 to 017, and the age category \"00-17\". This would not be included if the goal was to save space, as a single variable containing the age from 000 to 95+ could be grouped into intervals with a `mutate()` or `cut()` function.\n\nFrom here, I will use `dplyr`, as it is easier to read the operations performed on the data.\n\nI will explore the following questions:\n\n1. Are the age range equal to the age intervals? \n2. What do the sex categories represent?\n3. Exactly to what degree is the dataset full of duplicated data?\n\n#### Age range versus intervals\n\nTo figure out whether the age range versus the prespecified intervals have the same data, we can summarise a variable, here `turnover`, for the two groups, and see if they are the same.\n\nFirst, lets summarize `turnover` for the age interval \"00-17\".\n\n```{r}\n# Make a datset by filtering on 00-17\ndf_atc_2023_interval <- df_atc_2023 |> \n  filter(agegroup == \"00-17\")\n\n# Summarise it\nturnover_sum_interval <- df_atc_2023_interval |> \n  summarize(turnover = sum(turnover, na.rm = TRUE))\n```\n\n15.373.244 in 1000 DKK, so 15.373.244.000, or more than 15 billion DKK in 2023. For one age interval. Woav.\n\nNow, lets try to do it for the age range.\n\n```{r}\n# make vector to include in the filter\nnumbers <- sprintf(\"%03d\", 0:17)\n\n# Now filter in the same way as above, but for 000 to 017\ndf_atc_2023_range <- df_atc_2023 |> \n  filter(agegroup %in% numbers) \n  \n# Summarise\nturnover_sum_range  <- df_atc_2023_range |> mutate(\n    agegroup_combined = \n      ifelse(\n        agegroup %in% numbers, \n        \"000-017\", \n        agegroup)) |> \n  ungroup() |> \n  summarize(turnover = sum(turnover, na.rm = TRUE)) #, .groups = \"drop\")\nturnover_sum_range\n```\n\nNow lets compare.\n\n```{r}\n# Summary\nprint(turnover_sum_interval)\nprint(turnover_sum_range)\n\n# There is a difference.. How much? \n(print(turnover_sum_interval)-print(turnover_sum_range))\n```\n\nOkay, these two should be equal. Where did those 515.309.000 go? Thats a difference of `{r} round(((turnover_sum_interval-turnover_sum_range)/turnover_sum_range)*100,2)`%. The number calculated with inline R code - with \"{r} round(((turnover_sum_interval-turnover_sum_range)/turnover_sum_range)*100,2)\" surrounded by backticks - because that is nice to have in case you want to have your numbers in the text change accordingly with any change in the data you have done. Anyway.. what went wrong?\n\nHow very strange. How do I figure out why there is a difference?\n\nAre there the same amount of people in each category?\n\n```{r}\n# Count amount of people in each category\ncount_persons_range <- df_atc_2023 |> \n  filter(agegroup %in% numbers) |> \n  summarise(total = sum(count_persons))\ncount_persons_int <- df_atc_2023 |> \n  filter(agegroup == \"00-17\") |> \n  summarise(total = sum(count_persons))\n\n# Difference\ncount_persons_int-count_persons_range\n```\n\nOk. 131.087 people are missing from the \"range\" dataset. Thats a difference of `{r} round(((count_persons_int-count_persons_range)/count_persons_range)*100,2)`% I might have done something wrong. Or there is a mistake in the data.\n\n### Moving on\n\nLet's drop the other questions I wanted to ask above, atleast for now. A patient Data Scientist with a lot of time on their hands should probably find the cause of the error by doing some of the following:\n\n- Check the discrepancies across multiple variables\n- Recheck the \"Downloadbeskrivelse\" to see if the metadata for the data has a description of why there would be a descrepancy\n\nBecause if it was an error, this `{r} round(((turnover_sum_interval-turnover_sum_range)/turnover_sum_range)*100,2)`% difference in Turnover and `{r} round(((count_persons_int-count_persons_range)/count_persons_range)*100,2)`% difference in amount of people in the category is something I will let sit.\n\n**My main hypothesis** which just popped into my head just now is that since the data is missing from the `count_persons_range` dataset, it has something to do with removing observations from the original dataset that contains too much person-referable [personhenførbart] data.\n\n**Now**, with that in mind, I, an aspiring Data Scientist with a goal of making a blog post and not taking forever, will just use the data with age intervals, as according to my hypothesis, that is the most \"complete\" data.\n\n**With that dataset**, I will provide a brief overview of the drug classes with the highest turnover, by age group.\n\n#### Turnover by popular drug classes\n\nLet's start with the `df_atc_2023` dataset and:\n\n- Filter just the age-interval group, starting with \"00-17\"\n- Filter it down to just the following drug classes: GLP1, SGLT2, DPP4, BIGUANIDES (Metformin in this case), and INSULIN. ATC's are A10BJ, A10BK, A10BH, A10BA, and A10A.X, respectively \n- Summarize the drug classes over the age intervals, with a nice plot\n\n```{r}\n# Filter\ndf_atc_2023_filtered <- df_atc_2023 |> \n  filter(\n    str_detect(agegroup, \"-\") & \n    str_starts(atc, \"A10\")\n    )\nhead(df_atc_2023_filtered)\n```\n\n**Ok - another observation that popped up**: here I find evidence to support my hypothesis of data being deleted when it is too person-referable. Looking at the lowest ATC level (e.g. A10BJK01), there is \"0\" in `count_persons`, for at lot of the input. And the lowest number is \"5\". \n\nThis replacement of too low values with \"missing\" or \"0\" is frequently done to mask the fact that perhaps there were just 2 people receiving that drug in this year, which makes the probability that someone can identify who it is that much higher. So it is masking the data to protect the individuals who provided the data.\n\nMoving on, and taking that into account, I choose to filter on the drug class level, as it repeats anyway. E.g. for observations with `atc` = A10BJ, the data is summarised over the age groups, and within each A10BJ01..02..0n, I will find all that is contained in A10BJ. \n\n### Making a plot of the turnover by drug class\n\nNow, I have what I need to create the plots of turnover. I choose to make stacked bar charts, because I am used to making them, but there are probably better ways of representing the data. \n\nFirst, I prepare the data, by filtering out all the drug classes I do not wish to focus on, and making the y-axis more readable by dividing it with 1000, thus making it turnover in 1.000.000 of DKK\n\n```{r}\n# Create vector of drug classes \nDCs <- c(\"A10BJ\", \"A10BK\", \"A10BH\", \"A10BA\", \"A10BB\", \"A10BG\", \"A10BX\", \"A10A\") \n\n# Filter\ndf_atc_2023_filtered <- df_atc_2023_filtered |> \n  filter(atc %in% DCs) |> \n  mutate(\n    DC = case_when( # New drug class variable\n      atc == \"A10BJ\" ~ \"GLP1\", # GLP1\n      atc == \"A10BK\" ~ \"SGLT2\", # SGLT2\n      atc == \"A10BH\" ~ \"DPP4\", # DPP4\n      atc == \"A10BA\" ~ \"Metformin\", # MET\n      atc == \"A10BB\" ~ \"SU\", # SU\n      atc == \"A10BG\" ~ \"TZD\", # Thiazolidinediones\n      atc == \"A10BX\" ~ \"Others\", # Others\n      atc == \"A10A\"  ~ \"INSULIN\",  # INSULIN\n      TRUE ~ NA_character_  # Default to NA for all other values\n    ),\n    turnover1000k = turnover/1000 # 1000k because its already in 1000's.\n    )\n```\n\nNow its time to make the plot. \n\n```{r}\n# Plot - stacked bar chart\n  # total turnover\np1 <- ggplot(df_atc_2023_filtered, aes(x = agegroup, y = turnover1000k, fill = DC)) +\n  geom_bar(stat = \"identity\") +\n  labs(\n    title = \"Total turnover by drug class\",\n    caption = \"Source: own calculations based on data from medstat.dk via the Danish Health Data Authority\"\n    )\n  # propotional turnover for each group\np2 <- ggplot(df_atc_2023_filtered, aes(x = agegroup, y = turnover1000k, fill = DC)) +\n  geom_bar(stat = \"identity\", position = \"fill\") +\n  labs(\n    y = \"\",\n    title = \"Proportional turnover by drug class\",\n    caption = \"Source: own calculations based on data from medstat.dk via the Danish Health Data Authority\"\n    )\n\np1 \nggsave(\"thumbnail.png\", plot = last_plot(), width = 6, height = 4) # p1 saved as thumbnail\n\np2  \n\n```\n\nWell then.. The turnover for GLP1 in this country is quite impressive, with the 45 to 64 year olds taking by far the biggest piece of the pie. Thats about 6.000.000.000 DKK in turnover for that age group in 2023 alone.\n\nIn the next blog post I aim to show how to redo all that I did, as a function.\n\n**And hopefully it will also be a bit more organised**.\n","srcMarkdownNoYaml":"\n\n## Exploring Medstat data: Drug prescriptions in Denmark\n\nIn this post, I'll showcase how to work with publicly available drug prescription data from [medstat.dk](medstat.dk \"medstat.dk\"). This is a great way to practice data manipulation and analysis, using real-world data.\n\n### Downloading the data\n\nYou can download all the datasets from [medstat.dk's download section](https://medstat.dk/da/download). If you want to download multiple files and not have to work with the URLs, I recommend using the [downloadthemall](https://www.downthemall.net/) extension to batch download the data for easier local manipulation. \n\nSince I’m using GitHub to store my work, I’ll download the data directly from Medstat. GitHub has a 2GB storage limit per repository, which means large public datasets can quickly exceed this. Therefore, it’s important to manage the size of the files efficiently.\n\n### Loading and processing the data\n\nGood old trusty `tidyverse` has a lot of what I need, specifically the `readr` package, \"secretly\" loaded the library in an invisible chunk below, with `#| include: FALSE`, but also `#| warning: FALSE` because it wants to warn me about conflicts with the `tidyverse` package.\n    \n    #| include: FALSE\n    #| warning: FALSE\n    library(tidyverse)\n\n```{r}\n#| include: FALSE\n#| warning: FALSE\n\nlibrary(tidyverse)\n```\n\n### Fetching the data from medstat\n\nYou can use tools like the [MarkDownload](https://github.com/deathau/markdownload) extension to find the download links from the resulting markdown file it hands you. \n\nNow lets load an example dataset. \n\n```{r}\n#| message: FALSE\n\n# Define the URL for the dataset ()\nurl_atc_2023 <- \"https://medstat.dk/da/download/file/MjAyM19hdGNfY29kZV9kYXRhLnR4dA==\"\n\n# Read the dataset directly from the URL\ndf_atc_2023 <- read_delim(url_atc_2023, delim = \";\", show_col_types = FALSE)  # Assuming the file is tab-delimited\n\n# Print the first few rows of the dataset\nhead(df_atc_2023)\n```\n\nOk, this data is without headers. A way to save space probably. \n\n### Understanding the data structure\n\n**Thankfully** there is a documentation file the website: [Downloadbeskrivelse medstat](https://medstat.dk/apps/lms/public/dokumentation/Downloadbeskrivelse.pdf). This file explains the strucutre of the datasets and for the data that we look at, `YYYY_atc_code_data.txt`, the following variables apply (translated to English from the original Danish):\n\n- `atc`: Anatomical Therapeutic Chemical code\n- `year`: Year of data\n- `sector`: Healthcare sector\n- `region`: Geographic region\n- `sex`: Gender\n- `agegroup`: Age category\n- `count_persons`: Number of individuals\n- `count_persons_per1kpop`: Number of individuals per 1,000 population\n- `turnover`: Sales turnover\n- `reimbursement`: Reimbursements provided\n- `sold_amount`: Amount of drugs sold\n- `sold_amount_1kpop_day`: Amount sold per 1,000 population per day\n- `personreferabledata_perc`: Percentage of data referable to individuals\n\nSo we can use `colnames()` to transfer these column names to our dataset.\n\n```{r}\n# attach colnames\ncolnames(df_atc_2023) <- c(\"atc\",\"year\",\"sector\",\"region\",\"sex\",\"agegroup\",\"count_persons\",\"count_persons_per1kpop\",\"turnover\",\"reimbursement\", \"sold_amount\", \"sold_amount_1kpop_day\", \"personreferabledata_perc\")\n\n# View data\nhead(df_atc_2023)\nglimpse(df_atc_2023)\n```\n\nMissing name for one column that doesnt fit with the \"Downloadbeskrivelse medstat\". What is it?\n\n```{r}\n# call it something\ncolnames(df_atc_2023)[is.na(colnames(df_atc_2023))] <- \"missing_name\"\n\n# table of content\ntable(df_atc_2023$missing_name)\n\n```\n\nThis column is empty. Maybe just an artifact from the delim file. Lets assume we can safely remove it.\n\n```{r}\ndf_atc_2023 <- df_atc_2023 |>  select(-missing_name)\n```\n\n### Organising the data\n\nTime to figure out how this data is structured, and organise the character variables into factors. Factors, as you may know, are a data structure in R, which is akin to a categorisation, ordered or unordered. Since we have age, we probably have at least some age categories that are ordered in intervals. Lets find out what the different variables likely to be factors are.\n\n```{r}\n#| results: 'hide'\n\n# Finding all unique values even though i could just consult \"Downloadbeskrivelse medstat\"\nunique_values_all_columns <- unique(unlist(sapply(df_atc_2023, function(x) if(is.character(x)) unique(x))))\nprint(unique_values_all_columns)\n```\n\nWoops. I have hidden the massive output of this via `#| results: 'hide'`. I forgot that ATC has QUITE a lot of unique values. Lets make a data frame without the atc value.\n\n```{r}\n# Remove atc\ndf_atc_2023_mini <- df_atc_2023 |>  select(-atc)\n\n# Go through all variables that could be categories (often stored as characters by default) and display unique values\nunique(unlist(sapply(df_atc_2023_mini, function(x) if(is.character(x)) unique(x))))\n\n```\n\nOr, in a little more legible fashion, use some apply functions to first find the ones that are characters with `sapply()`, and then `lapply()` to create a list of all unique values of the character vars.\n\n```{r}\n# find character variables\nchar_columns <- df_atc_2023_mini[sapply(df_atc_2023_mini, is.character)]\n\n# apply the unique() function to each character variable\nunique_char_values <- lapply(char_columns, unique)\nunique_char_values\n\n```\n\n\nMore manageable amount of unique values. Although it seems there are multiple age categories within the `agegroup` variable. I will remove `df_atc_2023_mini` and `unique_char_values` as they were created for the purpose of creating an overview of the unique values.\n\n```{r}\nrm(df_atc_2023_mini, unique_char_values)\n```\n\nLets focus on the unique age groups. The data for age groups must be duplicated for the ranges 000 to 017, and the age category \"00-17\". This would not be included if the goal was to save space, as a single variable containing the age from 000 to 95+ could be grouped into intervals with a `mutate()` or `cut()` function.\n\nFrom here, I will use `dplyr`, as it is easier to read the operations performed on the data.\n\nI will explore the following questions:\n\n1. Are the age range equal to the age intervals? \n2. What do the sex categories represent?\n3. Exactly to what degree is the dataset full of duplicated data?\n\n#### Age range versus intervals\n\nTo figure out whether the age range versus the prespecified intervals have the same data, we can summarise a variable, here `turnover`, for the two groups, and see if they are the same.\n\nFirst, lets summarize `turnover` for the age interval \"00-17\".\n\n```{r}\n# Make a datset by filtering on 00-17\ndf_atc_2023_interval <- df_atc_2023 |> \n  filter(agegroup == \"00-17\")\n\n# Summarise it\nturnover_sum_interval <- df_atc_2023_interval |> \n  summarize(turnover = sum(turnover, na.rm = TRUE))\n```\n\n15.373.244 in 1000 DKK, so 15.373.244.000, or more than 15 billion DKK in 2023. For one age interval. Woav.\n\nNow, lets try to do it for the age range.\n\n```{r}\n# make vector to include in the filter\nnumbers <- sprintf(\"%03d\", 0:17)\n\n# Now filter in the same way as above, but for 000 to 017\ndf_atc_2023_range <- df_atc_2023 |> \n  filter(agegroup %in% numbers) \n  \n# Summarise\nturnover_sum_range  <- df_atc_2023_range |> mutate(\n    agegroup_combined = \n      ifelse(\n        agegroup %in% numbers, \n        \"000-017\", \n        agegroup)) |> \n  ungroup() |> \n  summarize(turnover = sum(turnover, na.rm = TRUE)) #, .groups = \"drop\")\nturnover_sum_range\n```\n\nNow lets compare.\n\n```{r}\n# Summary\nprint(turnover_sum_interval)\nprint(turnover_sum_range)\n\n# There is a difference.. How much? \n(print(turnover_sum_interval)-print(turnover_sum_range))\n```\n\nOkay, these two should be equal. Where did those 515.309.000 go? Thats a difference of `{r} round(((turnover_sum_interval-turnover_sum_range)/turnover_sum_range)*100,2)`%. The number calculated with inline R code - with \"{r} round(((turnover_sum_interval-turnover_sum_range)/turnover_sum_range)*100,2)\" surrounded by backticks - because that is nice to have in case you want to have your numbers in the text change accordingly with any change in the data you have done. Anyway.. what went wrong?\n\nHow very strange. How do I figure out why there is a difference?\n\nAre there the same amount of people in each category?\n\n```{r}\n# Count amount of people in each category\ncount_persons_range <- df_atc_2023 |> \n  filter(agegroup %in% numbers) |> \n  summarise(total = sum(count_persons))\ncount_persons_int <- df_atc_2023 |> \n  filter(agegroup == \"00-17\") |> \n  summarise(total = sum(count_persons))\n\n# Difference\ncount_persons_int-count_persons_range\n```\n\nOk. 131.087 people are missing from the \"range\" dataset. Thats a difference of `{r} round(((count_persons_int-count_persons_range)/count_persons_range)*100,2)`% I might have done something wrong. Or there is a mistake in the data.\n\n### Moving on\n\nLet's drop the other questions I wanted to ask above, atleast for now. A patient Data Scientist with a lot of time on their hands should probably find the cause of the error by doing some of the following:\n\n- Check the discrepancies across multiple variables\n- Recheck the \"Downloadbeskrivelse\" to see if the metadata for the data has a description of why there would be a descrepancy\n\nBecause if it was an error, this `{r} round(((turnover_sum_interval-turnover_sum_range)/turnover_sum_range)*100,2)`% difference in Turnover and `{r} round(((count_persons_int-count_persons_range)/count_persons_range)*100,2)`% difference in amount of people in the category is something I will let sit.\n\n**My main hypothesis** which just popped into my head just now is that since the data is missing from the `count_persons_range` dataset, it has something to do with removing observations from the original dataset that contains too much person-referable [personhenførbart] data.\n\n**Now**, with that in mind, I, an aspiring Data Scientist with a goal of making a blog post and not taking forever, will just use the data with age intervals, as according to my hypothesis, that is the most \"complete\" data.\n\n**With that dataset**, I will provide a brief overview of the drug classes with the highest turnover, by age group.\n\n#### Turnover by popular drug classes\n\nLet's start with the `df_atc_2023` dataset and:\n\n- Filter just the age-interval group, starting with \"00-17\"\n- Filter it down to just the following drug classes: GLP1, SGLT2, DPP4, BIGUANIDES (Metformin in this case), and INSULIN. ATC's are A10BJ, A10BK, A10BH, A10BA, and A10A.X, respectively \n- Summarize the drug classes over the age intervals, with a nice plot\n\n```{r}\n# Filter\ndf_atc_2023_filtered <- df_atc_2023 |> \n  filter(\n    str_detect(agegroup, \"-\") & \n    str_starts(atc, \"A10\")\n    )\nhead(df_atc_2023_filtered)\n```\n\n**Ok - another observation that popped up**: here I find evidence to support my hypothesis of data being deleted when it is too person-referable. Looking at the lowest ATC level (e.g. A10BJK01), there is \"0\" in `count_persons`, for at lot of the input. And the lowest number is \"5\". \n\nThis replacement of too low values with \"missing\" or \"0\" is frequently done to mask the fact that perhaps there were just 2 people receiving that drug in this year, which makes the probability that someone can identify who it is that much higher. So it is masking the data to protect the individuals who provided the data.\n\nMoving on, and taking that into account, I choose to filter on the drug class level, as it repeats anyway. E.g. for observations with `atc` = A10BJ, the data is summarised over the age groups, and within each A10BJ01..02..0n, I will find all that is contained in A10BJ. \n\n### Making a plot of the turnover by drug class\n\nNow, I have what I need to create the plots of turnover. I choose to make stacked bar charts, because I am used to making them, but there are probably better ways of representing the data. \n\nFirst, I prepare the data, by filtering out all the drug classes I do not wish to focus on, and making the y-axis more readable by dividing it with 1000, thus making it turnover in 1.000.000 of DKK\n\n```{r}\n# Create vector of drug classes \nDCs <- c(\"A10BJ\", \"A10BK\", \"A10BH\", \"A10BA\", \"A10BB\", \"A10BG\", \"A10BX\", \"A10A\") \n\n# Filter\ndf_atc_2023_filtered <- df_atc_2023_filtered |> \n  filter(atc %in% DCs) |> \n  mutate(\n    DC = case_when( # New drug class variable\n      atc == \"A10BJ\" ~ \"GLP1\", # GLP1\n      atc == \"A10BK\" ~ \"SGLT2\", # SGLT2\n      atc == \"A10BH\" ~ \"DPP4\", # DPP4\n      atc == \"A10BA\" ~ \"Metformin\", # MET\n      atc == \"A10BB\" ~ \"SU\", # SU\n      atc == \"A10BG\" ~ \"TZD\", # Thiazolidinediones\n      atc == \"A10BX\" ~ \"Others\", # Others\n      atc == \"A10A\"  ~ \"INSULIN\",  # INSULIN\n      TRUE ~ NA_character_  # Default to NA for all other values\n    ),\n    turnover1000k = turnover/1000 # 1000k because its already in 1000's.\n    )\n```\n\nNow its time to make the plot. \n\n```{r}\n# Plot - stacked bar chart\n  # total turnover\np1 <- ggplot(df_atc_2023_filtered, aes(x = agegroup, y = turnover1000k, fill = DC)) +\n  geom_bar(stat = \"identity\") +\n  labs(\n    title = \"Total turnover by drug class\",\n    caption = \"Source: own calculations based on data from medstat.dk via the Danish Health Data Authority\"\n    )\n  # propotional turnover for each group\np2 <- ggplot(df_atc_2023_filtered, aes(x = agegroup, y = turnover1000k, fill = DC)) +\n  geom_bar(stat = \"identity\", position = \"fill\") +\n  labs(\n    y = \"\",\n    title = \"Proportional turnover by drug class\",\n    caption = \"Source: own calculations based on data from medstat.dk via the Danish Health Data Authority\"\n    )\n\np1 \nggsave(\"thumbnail.png\", plot = last_plot(), width = 6, height = 4) # p1 saved as thumbnail\n\np2  \n\n```\n\nWell then.. The turnover for GLP1 in this country is quite impressive, with the 45 to 64 year olds taking by far the biggest piece of the pie. Thats about 6.000.000.000 DKK in turnover for that age group in 2023 alone.\n\nIn the next blog post I aim to show how to redo all that I did, as a function.\n\n**And hopefully it will also be a bit more organised**.\n"},"formats":{"html":{"identifier":{"display-name":"HTML","target-format":"html","base-format":"html"},"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":true,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"ipynb-shell-interactivity":null,"plotly-connected":true,"engine":"knitr"},"render":{"keep-tex":false,"keep-typ":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-min-runs":1,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[],"notebook-links":true},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","css":["../../styles.css"],"toc":true,"toc-depth":4,"self-contained":true,"output-file":"index.html"},"language":{"toc-title-document":"Table of contents","toc-title-website":"On this page","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","other-links-title":"Other Links","code-links-title":"Code Links","launch-dev-container-title":"Launch Dev Container","launch-binder-title":"Launch Binder","article-notebook-label":"Article Notebook","notebook-preview-download":"Download Notebook","notebook-preview-download-src":"Download Source","notebook-preview-back":"Back to Article","manuscript-meca-bundle":"MECA Bundle","section-title-abstract":"Abstract","section-title-appendices":"Appendices","section-title-footnotes":"Footnotes","section-title-references":"References","section-title-reuse":"Reuse","section-title-copyright":"Copyright","section-title-citation":"Citation","appendix-attribution-cite-as":"For attribution, please cite this work as:","appendix-attribution-bibtex":"BibTeX citation:","appendix-view-license":"View License","title-block-author-single":"Author","title-block-author-plural":"Authors","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Published","title-block-modified":"Modified","title-block-keywords":"Keywords","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Show All Code","code-tools-hide-all-code":"Hide All Code","code-tools-view-source":"View Source","code-tools-source-code":"Source Code","tools-share":"Share","tools-download":"Download","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Copy to Clipboard","copy-button-tooltip-success":"Copied!","repo-action-links-edit":"Edit this page","repo-action-links-source":"View source","repo-action-links-issue":"Report an issue","back-to-top":"Back to top","search-no-results-text":"No results","search-matching-documents-text":"matching documents","search-copy-link-title":"Copy link to search","search-hide-matches-text":"Hide additional matches","search-more-match-text":"more match in this document","search-more-matches-text":"more matches in this document","search-clear-button-title":"Clear","search-text-placeholder":"","search-detached-cancel-button-title":"Cancel","search-submit-button-title":"Submit","search-label":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Theorem","crossref-lem-title":"Lemma","crossref-cor-title":"Corollary","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Definition","crossref-exm-title":"Example","crossref-exr-title":"Exercise","crossref-ch-prefix":"Chapter","crossref-apx-prefix":"Appendix","crossref-sec-prefix":"Section","crossref-eq-prefix":"Equation","crossref-lof-title":"List of Figures","crossref-lot-title":"List of Tables","crossref-lol-title":"List of Listings","environment-proof-title":"Proof","environment-remark-title":"Remark","environment-solution-title":"Solution","listing-page-order-by":"Order By","listing-page-order-by-default":"Default","listing-page-order-by-date-asc":"Oldest","listing-page-order-by-date-desc":"Newest","listing-page-order-by-number-desc":"High to Low","listing-page-order-by-number-asc":"Low to High","listing-page-field-date":"Date","listing-page-field-title":"Title","listing-page-field-description":"Description","listing-page-field-author":"Author","listing-page-field-filename":"File Name","listing-page-field-filemodified":"Modified","listing-page-field-subtitle":"Subtitle","listing-page-field-readingtime":"Reading Time","listing-page-field-wordcount":"Word Count","listing-page-field-categories":"Categories","listing-page-minutes-compact":"{0} min","listing-page-category-all":"All","listing-page-no-matches":"No matching items","listing-page-words":"{0} words","listing-page-filter":"Filter","draft":"Draft"},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.7.32","editor":"source","theme":"darkly","fontsize":"0.9em","title-block-banner":true,"toc-location":"right","toc-title":"On this page","title":"Making sense of Medstat.dk data","author":"Henrik Vitus Bering Laursen","date":"2024-09-19","categories":["code","analysis","exploration","cost","drugs"],"image":"thumbnail.png"},"extensions":{"book":{"multiFile":true}}}},"projectFormats":["html"]}