---
title: "R and Pharmaverse packages"
author: "Henrik Vitus Bering Laursen"
date: "2025-08-31" 
categories: 
  - clinical data
  - data standards
  - data formats
format:
  html:
    toc: true
    number-sections: true
    fig-width: 8
    fig-height: 6
    code-fold: true
    code-summary: "Show the code" # only if |# echo: true
freeze: true
draft: true
#image: thumbnail.jpg
# THE FOLDER OF THIS FILE IS ON THE IGNORE LIST in C:\Users\henri\Documents\publicdataprojects\blog\.gitignore
---

## Purpose

Here I want to look at the clinical data pipeline. That is, a broad view of what is possible with R within the:

- Standard Data Tabulation Model, and
- submission-ready CDISC standard Analysis Data Model (ADaM) datasets

From what I can read, not all the R packages are fully developed - all of this is very much a work in progress, as the pharmaceutical industry is adopting more and more use of R.

So this will very much be playing around, learning as I go, with much less of a structure than what I usually want to display. 

**The summary chapter at the end will present at structured walkthrough of what I have learned**.

### Analysis plan

The plan is to look through a selection of packages within the `pharmaverse` and see what they contain, and try to apply some of the CDISC standards in a very basic and I'm-learning-as-I-go way.

In practice, this will look like:

- Finding packages
- Finding raw data
- Using packages to transform
  - raw data to SDTM
  - SDTM to ADaM
- Provide some output for a made-up requirement

## Process 
### Load

Googling a bit leads me to a function that loads multiple packages, which I will load up as we go along.

```{r}
#| label: libraries function
#| echo: false

# function to load many packages
ipak <- function(pkg){
  new.pkg <- pkg[!(pkg %in% installed.packages()[, "Package"])]
  if (length(new.pkg)) 
      install.packages(new.pkg, dependencies = TRUE)
  sapply(pkg, require, character.only = TRUE)
}
```

I just gotta... unpack... the above function and how I figured out how it works, so I can remember it better:

- Create a new object called "new.pkg", which is the packages which are not present in the column "Package" of the `installed.packages` output.
- If the `new.pkg` object has a length, it will install packages, and do nothing if there is not a length
- The `pkg` object is then looped over and `require`, which loads packages, tries to attach packages from the `pkg` object

In the future i will store this function in its own file so i can "source" it, i.e. run it from other scripts with a single line. Maybe even have an entire script full of my regularly used functions.

#### Probable main packages

The main ones I probably need, atleast from a pure working-with-data perspective, are loaded below. 

I gathered this from reading the `pharmaverse` website, blog, and asking GPT.

```{r}
#| label: initial libraries
#| output: false

packages <- c("admiral", "sdtm.oak", "pharmaverseraw", "pharmaversesdtm", "pharmaverseadam", "tidyverse")
ipak(packages)

```
**Alright**, that worked just fine.

Now, What does all this data look like?

#### Raw

Raw practice data can be found in the [`pharmaverseraw`](https://pharmaverse.github.io/pharmaverseraw/) package, so let's crack that one open.

Neatly, one can see the contents of a package by typing `packagename::`. For the above package, this reveals:

- ae_raw: adverse events
- dm_raw: demographics
- ds_raw: subject disposition
- ec_raw: exposure as collected
- vs_raw: vital signs

```{r}
#| label: pharmaverseraw look
#| echo: false
#| output: false

?pharmaverseraw::ae_raw
?pharmaverseraw::dm_raw
?pharmaverseraw::ds_raw
?pharmaverseraw::ec_raw
?pharmaverseraw::vs_raw

```

These are raw datasets with between 13 and 32 columns, and are the ones used to create the SDTM datasets present in `pharmaversesdtm`.

Let's look at the smallest dataset, `dm_raw`, to get a sense of what it contains.

```{r}
#| label: pharmaverseraw dm look
#| echo: true

# Load data
df1 <- pharmaverseraw::dm_raw

# Exploring data
str(df1)


```

Ok, so to get a good overview, I need to change some of the datas formats.

```{r}
#| label: pharmaverseraw format change
#| echo: true

# glimpse to copy column names
glimpse(df1) 

# vectors of columns to format
to_factor <- c("IT.SEX", "IT.ETHNIC", "IT.RACE", "COUNTRY", "PLANNED_ARM", "PLANNED_ARMCD", "ACTUAL_ARM", "ACTUAL_ARMCD")  

df1[to_factor] <- lapply(df1[to_factor], as.factor)

# dates contain NA so do individually
df1$IC_DT <- as.Date(df1$IC_DT, format = "%d/%m/%Y") 
df1$COL_DT <- as.Date(df1$COL_DT, format = "%d/%m/%Y") 

glimpse(df1)

# tables of factors and dates, and summaries
df1_test <- df1 |> 
  select(where(is.factor))

lapply(df1_test,table)

summary(df1$IT.AGE)
summary(df1$COL_DT)
summary(df1$IC_DT)

```
So we have:

- Mean age of 75 (range:50-89)
- About the same amount of people in the placebo, Xan High, and Xan Low, although the Xan High does have `{r} (72/96)*100`% of the amount of people that Xan Low has
- Many missing dates for `COL_DT` and `IC_DT`
- Majority of `r (table(df1$IT.SEX)[1]/(table(df1$IT.SEX)[1]+table(df1$IT.SEX)[2]))` % females
- `r (table(df1$IT.RACE)[4]/(table(df1$IT.RACE)[1]+table(df1$IT.RACE)[2]++table(df1$IT.RACE)[3]+table(df1$IT.RACE)[4]))*100`% white, and only two Asian and two American Indian or Alaska Natives

Now let's see the resulting SDTM dataset.

#### SDTM package

So, SDTM is a more standardised version of the raw data collected from clinical trials. Subject to more standards and uniformity, to make analysing and further transforming it more streamlined. 

Let's look at the same demographics dataset, from the [`pharmaversesdtm`](https://pharmaverse.github.io/pharmaversesdtm/) package, and what it looks like when it has been subjected to SDTM standards.

```{r}
#| label: pharmaversesdtm - look
#| echo: true

df2 <- pharmaversesdtm::dm

glimpse(df2)

```

Well, that's a few more columns than the raw dataset. Which probably means SDTM's version of a Demographics dataset requires more variables than the raw version - which, I guess, is because its not subject to the same standards as SDTM datasets.

So lets look at where those extra variables may have come from.

```{r}
#| label: pharmaversesdtm - where from fraw
#| echo: true

list_raw <- list(
  pharmaverseraw::ae_raw,
  pharmaverseraw::ds_raw,
  pharmaverseraw::ec_raw,
  pharmaverseraw::vs_raw
)

# compare glimpses to glimpse possible connections
lapply(list_raw, glimpse)
glimpse(df2)

```

#### ADaM package

**Also** you can download XPT format data directly from the [PHUSE TestDataFactory](adsl <- read_xpt("https://github.com/phuse-org/TestDataFactory/raw/main/Updated/TDF_ADaM"))

```{r}
#| label: pharmaverseadam - xpt
#| echo: true

adsl <- read_xpt("https://github.com/phuse-org/TestDataFactory/raw/main/Updated/TDF_ADaM/adsl.xpt")

```

--------------------------------------------------- 
NOTSURE I WANNA DO MY REGULAR STRUCTURE
--------------------------------------------------- 

### Output
#### Table

**Below is from https://bayer-group.github.io/sas2r/formatting.html**.

```{r}
#| label: ADSL table
#| echo: true

library(haven)

adsl <- read_xpt("https://github.com/phuse-org/TestDataFactory/raw/main/Updated/TDF_ADaM/adsl.xpt")

ipak("Tplyr")

options(
  # Categorical variable defaults
  tplyr.count_layer_default_formats =
    list(n_counts = f_str("xxx [xx.xx%]", n, pct)),
  
  # Continuous variable defaults
  tplyr.desc_layer_default_formats =
    list('N'         = f_str('xx', n),
         'Mean [SD]' = f_str('xx.xx [xx.xxx]', mean, sd),
         'Median'    = f_str('xx.x', median),
         'Min, Max'  = f_str('xx, xx', min, max))
)

# Initiate Tplyr, specify treatment variable, optional where condition
my_table <-  tplyr_table(adsl, TRT01P, where = SAFFL == "Y") %>%
  
  # Add a total group column
  add_total_group() %>%
  
  # Add individual variables here
  add_layer(group_desc(AGE, b = "Age (years)")) %>%
  add_layer(group_count(AGEGR1, b = "Age Group 1 (years)")) %>%
  add_layer(group_count(SEX, b = "Gender")) %>%
  add_layer(group_count(ETHNIC, b = "Ethnicity")) %>%
  add_layer(group_desc(BMIBL, b = "Baseline Body Mass Index (kg/m2)")) %>%
  
  # Build
  build()

head(my_table, n = 9)
```

```{r}
#| label: ADSL - more table
#| echo: true

my_table <- my_table %>%
  
  # remove repeating labels
  apply_row_masks(., row_breaks = TRUE) %>%
  
  # specify order of relevant variables
  select(row_label1, 
         row_label2,
         `var1_Xanomeline High Dose`,
         `var1_Xanomeline Low Dose`,
         var1_Placebo,
         var1_Total) 

head(my_table, n = 9)
```

Other packages than `Tplyr` help us DISPLAY the resulting table:

```{r}
#| label: ADSL - flextable
#| echo: true

ipak("flextable")

# a basic flextable
my_flextable <- my_table %>%
  
  # start flextable 
  flextable() %>%
  autofit()

my_flextable
```

```{r}
#| label: ADSL - flextable more pretty
#| echo: true

# a nicer flextable
my_flextable <- my_table %>%
  
  # start flextable 
  flextable() %>% 
  autofit() %>%
  
  # add some padding between rows
  padding(padding = 0.5) %>%
  
  # adjust width of first two columns
  width(j = 1:2, width = 4) %>%
  
  # align treatment columns to center
  align(part = "all", align = "center", j = 3:6) %>%
  
  # column header labels
  set_header_labels(., values = list(
    row_label1 = 'Variable',
    row_label2 = ' ',
    `var1_Xanomeline High Dose` = 'Xanomeline \nHigh Dose',
    `var1_Xanomeline Low Dose` = 'Xanomeline \nLow Dose',
    var1_Placebo = 'Placebo',
    var1_Total = 'Total')) %>%
  
  # header + footers
  add_header_lines(values = "Table: Demographics (Safety Analysis Set)") %>%
  add_footer_lines(values = "This was produced in R!") %>%
  
  # font size, font name
  fontsize(part = "all", size = 8)
  # font()
  # font(part = "all", fontname = "Times")  
  # This errors, perhaps version issue.  -- SZ
my_flextable
```

**To export to MS Word, we may use the `officer` package.**

```{r}
#| label: ADSL - export via officer package
#| echo: true

ipak("officer")

# send the flextable to .docx output
read_docx() %>%
  body_add_flextable(my_flextable) %>%
  print(target = "my_document.docx")

```

#### Graph
#### Model
## Summary / cleaned up / refactored 
```{r}
#| label: Summary chunk
#| echo: true
#| output: false
```


